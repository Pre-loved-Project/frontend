import{R as I}from"./iframe-D3jKPO7E.js";const k=t=>{let n;const e=new Set,a=(o,i)=>{const l=typeof o=="function"?o(n):o;if(!Object.is(l,n)){const S=n;n=i??(typeof l!="object"||l===null)?l:Object.assign({},n,l),e.forEach(g=>g(n,S))}},c=()=>n,d={setState:a,getState:c,getInitialState:()=>f,subscribe:o=>(e.add(o),()=>e.delete(o))},f=n=t(a,c,d);return d},E=(t=>t?k(t):k),R=t=>t;function $(t,n=R){const e=I.useSyncExternalStore(t.subscribe,I.useCallback(()=>n(t.getState()),[t,n]),I.useCallback(()=>n(t.getInitialState()),[t,n]));return I.useDebugValue(e),e}const w=t=>{const n=E(t),e=a=>$(n,a);return Object.assign(e,n),e},j=(t=>t?w(t):w);function P(t,n){let e;try{e=t()}catch{return}return{getItem:c=>{var s;const h=f=>f===null?null:JSON.parse(f,void 0),d=(s=e.getItem(c))!=null?s:null;return d instanceof Promise?d.then(h):h(d)},setItem:(c,s)=>e.setItem(c,JSON.stringify(s,void 0)),removeItem:c=>e.removeItem(c)}}const _=t=>n=>{try{const e=t(n);return e instanceof Promise?e:{then(a){return _(a)(e)},catch(a){return this}}}catch(e){return{then(a){return this},catch(a){return _(a)(e)}}}},O=(t,n)=>(e,a,c)=>{let s={storage:P(()=>localStorage),partialize:r=>r,version:0,merge:(r,v)=>({...v,...r}),...n},h=!1;const d=new Set,f=new Set;let o=s.storage;if(!o)return t((...r)=>{console.warn(`[zustand persist middleware] Unable to update item '${s.name}', the given storage is currently unavailable.`),e(...r)},a,c);const i=()=>{const r=s.partialize({...a()});return o.setItem(s.name,{state:r,version:s.version})},l=c.setState;c.setState=(r,v)=>(l(r,v),i());const S=t((...r)=>(e(...r),i()),a,c);c.getInitialState=()=>S;let g;const b=()=>{var r,v;if(!o)return;h=!1,d.forEach(u=>{var m;return u((m=a())!=null?m:S)});const y=((v=s.onRehydrateStorage)==null?void 0:v.call(s,(r=a())!=null?r:S))||void 0;return _(o.getItem.bind(o))(s.name).then(u=>{if(u)if(typeof u.version=="number"&&u.version!==s.version){if(s.migrate){const m=s.migrate(u.state,u.version);return m instanceof Promise?m.then(p=>[!0,p]):[!0,m]}console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return[!1,u.state];return[!1,void 0]}).then(u=>{var m;const[p,A]=u;if(g=s.merge(A,(m=a())!=null?m:S),e(g,!0),p)return i()}).then(()=>{y?.(g,void 0),g=a(),h=!0,f.forEach(u=>u(g))}).catch(u=>{y?.(void 0,u)})};return c.persist={setOptions:r=>{s={...s,...r},r.storage&&(o=r.storage)},clearStorage:()=>{o?.removeItem(s.name)},getOptions:()=>s,rehydrate:()=>b(),hasHydrated:()=>h,onHydrate:r=>(d.add(r),()=>{d.delete(r)}),onFinishHydration:r=>(f.add(r),()=>{f.delete(r)})},s.skipHydration||b(),g||S},H=O,L=j()(H(t=>({accessToken:null,isLogined:!1,setAccessToken:n=>t({accessToken:n}),setIsLogined:n=>t({isLogined:n}),logout:()=>t({accessToken:null,isLogined:!1})}),{name:"auth-storage",partialize:t=>({isLogined:t.isLogined})}));var U={};const B=U.NEXT_PUBLIC_API_URL;async function C(){try{const t=await fetch(`${B}/auth/refresh`,{method:"POST",credentials:"include"});if(!t.ok)return null;const e=(await t.json()).accessToken;return L.getState().setAccessToken(e),e}catch{return null}}var x={};const T=x.NEXT_PUBLIC_API_URL;async function F(t,n){const{headers:e,noAuth:a,...c}=n,{accessToken:s,setAccessToken:h,logout:d}=L.getState(),f={"Content-Type":"application/json"};let o=await fetch(`${T}${t}`,{headers:{...f,...e},cache:"no-store",...c});if(o.status===401&&!a){const i=await C();if(i)h(i),f.Authorization=`Bearer ${i}`,o=await fetch(`${T}${t}`,{headers:{...f,...e},cache:"no-store",...c});else throw d(),new Error("세션이 만료되었습니다. 다시 로그인 해주세요.")}if(!o.ok){let i=`API Error ${o.status}`;try{const l=await o.json();i=l.message??l.detail??i}catch{const l=await o.text();l&&(i=l)}throw new Error(i)}return o.json()}export{F as a,L as u};
