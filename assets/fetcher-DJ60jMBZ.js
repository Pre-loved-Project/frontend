import{R as y}from"./iframe-vISGKOMF.js";const _=t=>{let e;const n=new Set,o=(a,g)=>{const c=typeof a=="function"?a(e):a;if(!Object.is(c,e)){const l=e;e=g??(typeof c!="object"||c===null)?c:Object.assign({},e,c),n.forEach(u=>u(e,l))}},i=()=>e,h={setState:o,getState:i,getInitialState:()=>m,subscribe:a=>(n.add(a),()=>n.delete(a))},m=e=t(o,i,h);return h},A=(t=>t?_(t):_),j=t=>t;function x(t,e=j){const n=y.useSyncExternalStore(t.subscribe,y.useCallback(()=>e(t.getState()),[t,e]),y.useCallback(()=>e(t.getInitialState()),[t,e]));return y.useDebugValue(n),n}const E=t=>{const e=A(t),n=o=>x(e,o);return Object.assign(n,e),n},O=(t=>t?E(t):E);function R(t,e){let n;try{n=t()}catch{return}return{getItem:i=>{var r;const f=m=>m===null?null:JSON.parse(m,void 0),h=(r=n.getItem(i))!=null?r:null;return h instanceof Promise?h.then(f):f(h)},setItem:(i,r)=>n.setItem(i,JSON.stringify(r,void 0)),removeItem:i=>n.removeItem(i)}}const b=t=>e=>{try{const n=t(e);return n instanceof Promise?n:{then(o){return b(o)(n)},catch(o){return this}}}catch(n){return{then(o){return this},catch(o){return b(o)(n)}}}},B=(t,e)=>(n,o,i)=>{let r={storage:R(()=>localStorage),partialize:s=>s,version:0,merge:(s,v)=>({...v,...s}),...e},f=!1;const h=new Set,m=new Set;let a=r.storage;if(!a)return t((...s)=>{console.warn(`[zustand persist middleware] Unable to update item '${r.name}', the given storage is currently unavailable.`),n(...s)},o,i);const g=()=>{const s=r.partialize({...o()});return a.setItem(r.name,{state:s,version:r.version})},c=i.setState;i.setState=(s,v)=>(c(s,v),g());const l=t((...s)=>(n(...s),g()),o,i);i.getInitialState=()=>l;let u;const k=()=>{var s,v;if(!a)return;f=!1,h.forEach(d=>{var S;return d((S=o())!=null?S:l)});const p=((v=r.onRehydrateStorage)==null?void 0:v.call(r,(s=o())!=null?s:l))||void 0;return b(a.getItem.bind(a))(r.name).then(d=>{if(d)if(typeof d.version=="number"&&d.version!==r.version){if(r.migrate){const S=r.migrate(d.state,d.version);return S instanceof Promise?S.then(I=>[!0,I]):[!0,S]}console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return[!1,d.state];return[!1,void 0]}).then(d=>{var S;const[I,L]=d;if(u=r.merge(L,(S=o())!=null?S:l),n(u,!0),I)return g()}).then(()=>{p?.(u,void 0),u=o(),f=!0,m.forEach(d=>d(u))}).catch(d=>{p?.(void 0,d)})};return i.persist={setOptions:s=>{r={...r,...s},s.storage&&(a=s.storage)},clearStorage:()=>{a?.removeItem(r.name)},getOptions:()=>r,rehydrate:()=>k(),hasHydrated:()=>f,onHydrate:s=>(h.add(s),()=>{h.delete(s)}),onFinishHydration:s=>(m.add(s),()=>{m.delete(s)})},r.skipHydration||k(),u||l},H=B,P=O()(H(t=>({accessToken:null,isLogined:!1,setAccessToken:e=>t({accessToken:e}),setIsLogined:e=>t({isLogined:e}),logout:()=>t({accessToken:null,isLogined:!1})}),{name:"auth-storage",partialize:t=>({isLogined:t.isLogined})}));class w extends Error{constructor(e,n){super(e),this.status=n,this.name=this.constructor.name}}class U extends w{constructor(e="인증이 필요합니다."){super(e,401)}}class $ extends w{constructor(e="요청한 리소스를 찾을 수 없습니다."){super(e,404)}}class T extends w{constructor(e="서버 오류가 발생했습니다."){super(e,500)}}var C={};const F=C.NEXT_PUBLIC_API_URL;async function J(t,e={}){const{headers:n,noAuth:o,useBaseUrl:i=!0,...r}=e,{accessToken:f,setAccessToken:h,logout:m}=P.getState(),a={"Content-Type":"application/json"};!o&&f&&(a.Authorization=`Bearer ${f}`);const g=i?`${F}${t}`:t;let c=await fetch(g,{headers:{...a,...n},credentials:"include",cache:"no-store",...r});if(c.status===401&&!o){const l=await fetch("/api/auth/refresh",{method:"POST",credentials:"include"});if(!l.ok)throw m(),new U(`세션이 만료되었습니다.
다시 로그인 해주세요.`);const{accessToken:u}=await l.json();h(u),a.Authorization=`Bearer ${u}`,c=await fetch(g,{headers:{...a,...n},credentials:"include",cache:"no-store",...r})}if(!c.ok){if(c.status===404)throw new $;if(c.status>=500)throw new T;let l=`API Error ${c.status}`;try{const u=await c.json();l=u.message??u.detail??l}catch{const u=await c.text();u&&(l=u)}throw new T(l)}return c.json()}export{J as a,O as c,P as u};
